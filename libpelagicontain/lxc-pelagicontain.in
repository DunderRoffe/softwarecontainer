#!/bin/bash -e

#
# lxc: linux Container library

# Authors:
# Daniel Lezcano <daniel.lezcano@free.fr>
# Tobias Olausson <tobias.olausson@pelagicore.com>

# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.

# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.

# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

install_busybox()
{
    rootfs=$1
    name=$2
    res=0
    tree="\
        $rootfs/bin \
        $rootfs/dev \
        $rootfs/dev/pts \
        $rootfs/dev/shm \
        $rootfs/dev/dri \
        $rootfs/etc \
        $rootfs/etc/init.d \
        $rootfs/etc/pulse \
        $rootfs/home \
        $rootfs/lib \
        $rootfs/lib64 \
        $rootfs/mnt \
        $rootfs/proc \
        $rootfs/root \
        $rootfs/sbin \
        $rootfs/usr/bin \
        $rootfs/usr/lib \
        $rootfs/usr/lib64 \
        $rootfs/usr/sbin \
        $rootfs/usr/share/udhcpc \
        $rootfs/tmp \
        $rootfs/var/log \
        $rootfs/gateways \
        $rootfs/${CMAKE_INSTALL_PREFIX} \
        ${ADDITIONAL_FOLDER_MOUNTS}"

    mkdir -p $tree || return 1
    chmod 755 $tree || return 1

    pushd $rootfs/dev > /dev/null || return 1

    # minimal devices needed for busybox
    mknod tty c 5 0       || res=1
    mknod console c 5 1   || res=1
    chmod 666 tty console || res=1
    mknod tty0 c 4 0      || res=1
    mknod tty1 c 4 0      || res=1
    mknod tty5 c 4 0      || res=1
    chmod 666 tty0        || res=1
    mknod ram0 b 1 0      || res=1
    chmod 600 ram0        || res=1
    mknod null c 1 3      || res=1
    chmod 666 null        || res=1
    mknod urandom c 1 9   || res=1
    chmod 666 urandom     || res=1

    popd > /dev/null

    # Create entry for root user in /etc/passwd
    echo "root:x:0:0:root:/root:/bin/sh" >> $rootfs/etc/passwd
    echo "root:x:0:root" >> $rootfs/etc/group

    # mount everything
    cat <<EOF >> $rootfs/etc/init.d/rcS
#!/bin/sh
/bin/syslogd
/bin/mount -a
/bin/udhcpc
EOF

    # executable
    chmod 744 $rootfs/etc/init.d/rcS || return 1

    # mount points
    cat <<EOF >> $rootfs/etc/fstab
proc  /proc      proc    defaults     0      0
shm   /dev/shm   tmpfs   defaults     0      0
EOF

    # writable and readable for other
    chmod 644 $rootfs/etc/fstab || return 1

    # launch rcS first then make a console available
    # and propose a shell on the tty, the last one is
    # not needed
    cat <<EOF >> $rootfs/etc/inittab
::sysinit:/etc/init.d/rcS
tty1::respawn:/bin/getty -L tty1 115200 vt100
console::askfirst:/bin/sh
EOF
    # writable and readable for other
    chmod 644 $rootfs/etc/inittab || return 1

    cat <<EOF >> $rootfs/usr/share/udhcpc/default.script
#!/bin/sh
case "\$1" in
    deconfig)
        ip addr flush dev \$interface
        ;;

    renew|bound)
        # flush all the routes
        if [ -n "\$router" ]; then
            ip route del default 2> /dev/null
        fi

        # check broadcast
        if [ -n "\$broadcast" ]; then
            broadcast="broadcast \$broadcast"
        fi

        # add a new ip address
        ip addr add \$ip/\$mask \$broadcast dev \$interface

        if [ -n "\$router" ]; then
            ip route add default via \$router dev \$interface
        fi

        [ -n "\$domain" ] && echo search \$domain > /etc/resolv.conf
        for i in \$dns ; do
            echo nameserver \$i >> /etc/resolv.conf
        done
        echo "nameserver 10.0.3.1" >> /etc/resolv.conf
        ;;
esac
exit 0
EOF
    chmod 744 $rootfs/usr/share/udhcpc/default.script
    echo "disable-shm=yes" >> $rootfs/etc/pulse/client.conf
    echo `dbus-uuidgen` >> $rootfs/etc/machine-id # For D-Bus
    cp /etc/resolv.conf $rootfs/etc/resolv.conf
    echo "nameserver 10.0.3.1" >> $rootfs/etc/resolv.conf

    return $res
}

configure_busybox()
{
    rootfs=$1

    which busybox >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        echo "busybox executable is not accessible"
        return 1
    fi

    # copy busybox in the rootfs
    cp $(which busybox) $rootfs/bin
    if [ $? -ne 0 ]; then
        echo "failed to copy busybox in the rootfs"
        return 1
    fi

    # symlink busybox for the commands it supports
    pushd $rootfs/bin > /dev/null || return 1
    for comm in $(./busybox --list); do
        ln -s busybox $comm
    done
    popd > /dev/null || return 1

    # relink /sbin/init
    ln $rootfs/bin/busybox $rootfs/sbin/init

    return 0
}

copy_configuration()
{
    path=$1
    rootfs=$2
    name=$3

    grep -q "^lxc.rootfs" $path/config 2>/dev/null || echo "lxc.rootfs = $rootfs" >> $path/config
    echo "lxc.utsname = $name" >> $path/config
    echo "lxc.tty = 1" >> $path/config
    echo "lxc.pts = 1" >> $path/config
    echo "lxc.mount.entry = ${CMAKE_INSTALL_PREFIX} $rootfs/${CMAKE_INSTALL_PREFIX} none ro,bind 0 0" >> $path/config

    # Bind-mount the directory containing init.lxc to /usr/sbin. This is typically
    # /usr/sbin on the host as well.
    INITLXCFILE=`which init.lxc`
    if [ $? -ne 0 ]; then
        echo "Error in template: init.lxc not found, unable to mount containing directory to /usr/sbin in container"
    else
        INITLXCDIR=$(dirname $INITLXCFILE)
        echo "lxc.mount.entry = $INITLXCDIR $rootfs/usr/sbin none ro,bind 0 0" >> $path/config
    fi

    if [ -n "$GATEWAY_DIR" ]; then
        echo "lxc.mount.entry = $GATEWAY_DIR gateways none rw,bind 0 0" >> $path/config

        # the gateway folder needs to be writable since wayland requires some extra
        # files to be created by the client in the folder where the wayland socket
        # is located
        chmod o+rwx $GATEWAY_DIR
        chmod g+rwx $GATEWAY_DIR
    fi

    mountdirs="\
        usr \
        lib \
        lib64 \
        usr/lib \
        usr/lib64"

    for dir in $mountdirs; do
	if [ -d "/$dir" ] && [ -d "$rootfs/$dir" ]; then
	    echo "lxc.mount.entry = /$dir $dir none ro,bind 0 0" >> $path/config
	fi
    done
}

usage()
{
    echo "$1 -h|--help -p|--path=<path>|--rootfs=<path>"
    return 0
}

options=$(getopt -o hp:n: -l help,path:,name:,rootfs: -- "$@")
if [ $? -ne 0 ]; then
    usage $(basename $0)
    exit 1
fi
eval set -- "$options"

while true
do
    case "$1" in
        -h|--help)      usage $0 && exit 0;;
        -p|--path)      path=$2; shift 2;;
        -n|--name)      name=$2; shift 2;;
        --rootfs)       rootfs=$2; shift 2;;
        --)             shift 1; break ;;
        *)              break ;;
    esac
done

if [ "$(id -u)" != "0" ]; then
    echo "This script should be run as 'root'"
    exit 1
fi

if [ -z "$path" ]; then
    echo "'path' parameter is required"
    exit 1
fi

# detect rootfs
if [ -z "$rootfs" ]; then
    config="$path/config"
    if grep -q '^lxc.rootfs' $config 2>/dev/null ; then
        rootfs=`grep 'lxc.rootfs =' $config | awk -F= '{ print $2 }'`
    else
        rootfs=$path/rootfs
    fi
fi

install_busybox $rootfs $name
if [ $? -ne 0 ]; then
    echo "failed to install busybox's rootfs"
    exit 1
fi

configure_busybox $rootfs
if [ $? -ne 0 ]; then
    echo "failed to configure busybox template"
    exit 1
fi

copy_configuration $path $rootfs $name
if [ $? -ne 0 ]; then
    echo "failed to write configuration file"
    exit 1
fi
